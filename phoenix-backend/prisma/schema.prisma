generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Sender {
  user
  admin
}

enum TicketStatus {
  open
  pending
  closed
}

// ⬅️ نوع تیکت
enum TicketType {
  tech    // پشتیبانی فنی
  therapy // ارتباط با درمانگر
}

model Ticket {
  id          String       @id @default(uuid())
  title       String
  description String
  contact     String?
  status      TicketStatus @default(open)
  type        TicketType   @default(tech)

  pinned       Boolean @default(false)
  unread       Boolean @default(false)
  openedById   String?
  openedByName String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Message[]
}

enum MessageType {
  text
  voice
  image
  file
}

model Message {
  id String @id @default(uuid())

  ticketId String
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  sender Sender

  type        MessageType @default(text)
  text        String?
  fileUrl     String?
  mime        String?
  size        Int?
  durationSec Int?
  createdAt   DateTime @default(now())

  @@index([ticketId])
}

enum AdminRole {
  owner
  manager
  agent
}

model Admin {
  id           String    @id @default(uuid())
  email        String    @unique
  name         String
  apiKey       String    @unique
  passwordHash String?
  role         AdminRole @default(agent)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  sessions AdminSession[]
}

model AdminSession {
  id        String    @id @default(uuid())
  adminId   String
  admin     Admin     @relation(fields: [adminId], references: [id], onDelete: Cascade)
  token     String    @unique
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
}

model AiMemory {
  id        String   @id @default(uuid())
  userId    String   @unique
  summary   String   @default("")
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

/**
 * ----------- User + Subscription برای اپ ققنوس -----------
 */

enum SubscriptionStatus {
  pending
  active
  expired
  canceled
}

// ✅ پلن را به صورت رشته ذخیره می‌کنیم: 'free' | 'pro' | 'vip'
model User {
  id        String    @id @default(uuid())
  phone     String    @unique
  fullName  String?   @default("")
  gender    String? // male / female / other
  birthDate DateTime?

  plan          String    @default("free") // 'free' | 'pro' | 'vip'
  planExpiresAt DateTime?

  profileCompleted Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions Subscription[]

  // ✅ Announcements
  announcementSeen AnnouncementSeen[]

  // ✅ NEW: پیشرفت پلکان (یک رکورد برای هر کاربر)
  pelekanProgress PelekanProgress?

  // ✅ NEW: نتایج آزمون‌ها
  assessments AssessmentResult[]
}

model Subscription {
  id String @id @default(uuid())

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  phone     String
  authority String  @unique
  refId     String?

  amount Int
  months Int
  plan   String
  status SubscriptionStatus @default(pending)

  expiresAt DateTime

  createdAt DateTime  @default(now())
  paidAt    DateTime?

  @@index([userId])
  @@index([phone])
}

/**
 * -------------------- Announcements --------------------
 */

enum AnnouncementPlacement {
  top_banner
}

enum AnnouncementLevel {
  info
  warning
  critical
}

model Announcement {
  id        String                @id @default(uuid())
  title     String?
  message   String
  level     AnnouncementLevel     @default(info)
  placement AnnouncementPlacement @default(top_banner)

  // ✅ اجباری/اختیاری (اجباری یعنی dismissible=false)
  dismissible Boolean @default(true)

  // ✅ فعال/غیرفعال
  enabled Boolean @default(true)

  /**
   * ✅ مخاطب‌ها (چندتا با هم)
   * - عمومی: free+pro=true
   * - فقط رایگان: targetFree=true, بقیه false
   * - فقط پرو: targetPro=true, بقیه false
   * - تمدید: targetExpiring=true و/یا targetExpired=true
   *
   * نکته: اینجا دیتابیس جلوی "همه false" را نمی‌گیرد؛
   * باید در API validate کنی حداقل یکی true باشد.
   */
  targetFree     Boolean @default(true)
  targetPro      Boolean @default(true)
  targetExpiring Boolean @default(false)
  targetExpired  Boolean @default(false)

  // زمان‌بندی
  startAt DateTime?
  endAt   DateTime?

  // ترتیب نمایش (عدد بزرگ‌تر یعنی بالاتر)
  priority Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seenBy AnnouncementSeen[]

  // ✅ indexes برای کوئری active
  @@index([enabled, placement, priority])
  @@index([startAt, endAt])
}

model AnnouncementSeen {
  id             String   @id @default(uuid())
  announcementId String
  userId         String
  seenAt         DateTime @default(now())

  announcement Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([announcementId, userId])
  @@index([userId])
  @@index([announcementId])
}

/**
 * -------------------- Pelekan Progress --------------------
 * هدف:
 * - ذخیره‌ی وضعیت مسیر (step/day/gems/streak)
 * - سینک بین دستگاه‌ها
 * - ثبت آخرین تعامل و ریست/شروع از صفر
 *
 * نکته مهم: dayIndex اینجا 0-based است.
 */

model PelekanProgress {
  id String @id @default(uuid())

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  stepIndex Int @default(1) // مثلا 1..3
  dayIndex  Int @default(0) // ✅ 0-based

  gems   Int @default(0)
  streak Int @default(1) // ✅ با پیش‌فرض اپ همخوان‌تر

  // تحلیل و سینک
  startedAt    DateTime @default(now())
  lastActiveAt DateTime @default(now())

  resetCount Int      @default(0)
  resetAt    DateTime?

  // اگر خواستی جلوی overwrite قدیمی‌تر را بگیری (برای سینک):
  version Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([lastActiveAt])
  @@index([updatedAt])
}

/**
 * -------------------- Assessments --------------------
 * دو جای آزمون:
 * - نوع A: بدون زیرمقیاس (total فقط)
 * - نوع B: با زیرمقیاس‌ها (JSON)
 *
 * نکته: چون Prisma شرطی ندارد، enforce کردن اینکه
 * heartbreak_simple حتما totalScore داشته باشد را در API انجام می‌دهیم.
 */

enum AssessmentKind {
  heartbreak_simple   // آزمون فعلیِ بدون زیرمقیاس
  heartbreak_scales   // آزمون آینده‌دار با زیرمقیاس
}

model AssessmentResult {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  kind AssessmentKind

  // امتیاز کلی (برای simple باید اجباری باشد؛ enforce در API)
  totalScore Int?

  // زیرمقیاس‌ها / آیتم‌ها / متادیتا
  // مثال: {"avoidance":12,"rumination":18,"sleep":7}
  scales Json?

  // موج/دفعه: baseline=1, followup1=2, followup2=3
  wave Int @default(1)

  takenAt DateTime @default(now())

  @@unique([userId, kind, wave])
  @@index([userId])
  @@index([kind])
  @@index([userId, kind])
}